<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | RumbleSan Heavy Noise Industries]]></title>
  <link href="http://rumblesan.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://rumblesan.com/"/>
  <updated>2012-12-16T21:40:44+00:00</updated>
  <id>http://rumblesan.com/</id>
  <author>
    <name><![CDATA[guy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PatchWerk Radio: How it works and how to write patches for it]]></title>
    <link href="http://rumblesan.com/blog/2011/01/29/patchwerk-radio-how-it-works-and-how-to-write-patches-for-it/"/>
    <updated>2011-01-29T17:35:39+00:00</updated>
    <id>http://rumblesan.com/blog/2011/01/29/patchwerk-radio-how-it-works-and-how-to-write-patches-for-it</id>
    <content type="html"><![CDATA[<p>So how exactly does PatchWerk Radio work? What is it doing? How do the loaded patches interact with the main program? How can I write patches that will run on it?</p>

<p>Hopefully by the end of this article I will have answered all these questions and given you all you need to know to go about writing your own patches for PatchWerk Radio. These instructions will probably be updated in the future as more things get added and neatened up, but for the moment they should be fine.</p>

<p>So to start off, a diagram showing roughly what’s involved.</p>

<p><img src="/a/2011-01-29-patchwerk-radio-how-it-works-and-how-to-write-patches-for-it/PatchWerk-Radio-Program-Diagram.png" alt="PatchWerk Radio Program Diagram" /></p>

<p>The Python script is the heart of the whole thing. It’s responsible for starting up a PureData sub-process, getting it to load up the master control patch, sending it all the streaming settings, choosing which patches it will load and then fading between them. All of this is done over a network connection between PD and Python and uses a slightly modified version of the <a href="http://mccormick.cx/projects/PyPd/">PyPD</a> class written by <a href="http://mccormick.cx">Chris McCormick</a>.</p>

<p>The masterPatch is just an ordinary PD patch that deals with the cross fading, the streaming, the dynamic patch loading and the routing of messages between these sections. It has a number of sub sections each of which handle their different tasks.</p>

<ul>
  <li>
    <p>The python-interface sub-patch deals with the network communications between the patch and Python.</p>
  </li>
  <li>
    <p>The volume-control sub-patch just does the cross fading between the audio of the loaded patches.</p>
  </li>
  <li>
    <p>The patch-control section is responsible for loading and closing the chosen patches using the dynamic messaging properties of PD.</p>
  </li>
  <li>
    <p>The patch-interfaces are the important ones. This is where the audio from the dynamically loaded patches comes into the master patch and then gets routed to the streaming section. It contains two receive~ objects for left and right channels and the logic to change where these will get their data from. It’s also where the messages to the loaded patches from the master patch are routed through.</p>
  </li>
  <li>
    <p>The streaming sub-patch contains the oggcast~ object and all the routing to get the settings messages from python and format them correctly. The audio from the loaded patches gets routed to here from where it is streamed to the internet at large.</p>
  </li>
</ul>

<p>The audio patches themselves are treated by PD exactly as if the patch were opened from the file menu. This is good because it means that messages and audio data can easily be sent between it and the master without having to do any routing external with JACK for example. The drawback is that we cant just have an object and connect it up using patch cords, nor can we just give it a pre-defined set of send~ objects at the output because PD doesn’t like that. As well as that, we have to be careful with how we name objects such as send and receives in case patches interfere with one another.</p>

<p>My solution to this was to use the abstraction arguments that PD has, specifically the $0 arg that gives the unique object number of the encompassing sub-patch/abstraction.</p>

<p>In each of the loadable patches there is an abstraction called patchComs. The audio from the patch is routed into this (There’s also a switch~ object hanging off it, more on that later) where inside the audio is connected to two send objects named $0-l and $0-r. There is also a small section featuring a loadbang, an int with a $0 argument and a “send masterCom” object. Here’s a picture for those who don’t want to go and load it up. The switch~ is outside of this patch hanging off that outlet.</p>

<p><img src="/a/2011-01-29-patchwerk-radio-how-it-works-and-how-to-write-patches-for-it/patchComs.png" alt="patchComs abstraction" /></p>

<p>When the patch is loaded the unique $0 argument gets sent, via the masterCom send object, to the python-interface in the master patch which sends it on to python. After it loads each new patch python waits for this message and when it receives it, registers that this is the unique id number for the patch. It will then send a registration message back to the master patch which will update one pair of receive~ objects to start getting their audio from the new send~ objects. A similar thing is done with the message sending objects. This is all done inside the patch-interface sections.</p>

<p><img src="/a/2011-01-29-patchwerk-radio-how-it-works-and-how-to-write-patches-for-it/patch-interface.png" alt="patch-interface abstraction" /></p>

<p>Currently the only message from python to the new patch is one that turns on the DSP processing. Initially the switch~ hanging off the patchComs abstraction stops all DSP processing and is there to try and minimise the effects of a CPU usage spike on the audio. Once the patch is fully loaded and registered the DSP gets turned on.</p>

<p>Once the patch is making noise, Python gets the master patch to fade over to the new output channel, waits until this is done, then it closes the old patch. There are a few other housekeeping things done here such as turning off the DSP in the old patch and changing the receive~ objects to get their input from the dummy sends~. Once this is done it will sleep for ten minutes until it needs to choose the next patch to load. There are a few checks in place to make sure the same patch isn’t loaded and that patches register themselves properly, but really everything is pretty simple.</p>

<p>There are a few things that need to be noted before making a patch for PatchWerk Radio. Because the patches are loaded under the same instance of PD, they could possibly interfere with each other, This means that sends and receives should ideally have arguments to make sure that they will be unique within your patch and that abstractions themselves should have fairly specific names if you’re using them in your patch.</p>

<ol>
  <li>
    <p>When the Python script is choosing the next patch to load it will pick a random folder from it’s given patch directory. Once it has a folder it will <em>*check inside this folder for a patch named main-</em>.pd **and then load this if it finds it. If it doesn’t find it then it will try again so make sure the patch you want loaded follows this naming convention.</p>
  </li>
  <li>
    <p>Because of the way that the close message in PD works, <strong>each main patch must have a unique name</strong>. Currently I’m just naming everything with incrementing numbers in folder names and main patch names and that should be fine for the moment. If it becomes an issue then I’ll come up with something else.</p>
  </li>
  <li>
    <p><strong>Patches need to be totally stand-alone</strong>. They need to start on their own and play on their own. In the future I hope to add the ability for information (weather, stock prices, music scales etc) to be requested from the master patch but for the moment your patch has to do everything by itself.</p>
  </li>
  <li>
    <p><strong>Patches play for about ten minutes</strong> so bear this in mind. Again, in future I hope to have this be specifiable on a per patch basis bit it’s not here yet.</p>
  </li>
  <li>
    <p><strong>Objects such as send, receive, delay chains and buffers need to use $0 arguments to make sure they’re unique.</strong> Otherwise there might be inter patch interference. I need to fix this in some of the patches already in the repository so it’s not a horrendous problem so far but better not to do it.</p>
  </li>
</ol>

<p>That’s really everything there is to it. I still want to do work on the basic infrastructure of the system but that shouldn’t affect the design of the patches. For those who are interested in getting involved, I’ll point your towards the <a href="https://github.com/notesandvolts/Radio-Patches">patch repository on GitHub</a>. You can either fork it on there and then send me pull requests, or get in contact with me and send me the patches so I can put them in.</p>

<p>Ask questions in the comments in case I’ve missed anything out. Now I’m just going to spend some time writing more patches, hope you’ll come and join me.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PatchWerk Radio is Go, and it needs YOU!!]]></title>
    <link href="http://rumblesan.com/blog/2011/01/28/patchwerk-radio-is-go-and-it-needs-you/"/>
    <updated>2011-01-28T00:24:37+00:00</updated>
    <id>http://rumblesan.com/blog/2011/01/28/patchwerk-radio-is-go-and-it-needs-you</id>
    <content type="html"><![CDATA[<p>I know I said I’d write this a few days ago, but I decided I’d rather spend a little bit of extra time getting everything sorted so that everything would be up and running when I wanted to explain it all. The short summary is that Radio Drone is now known as PatchWerk Radio, it’s all working and running off a VPS server, all the code and patches are on GitHub and, most importantly, you can listen to it right now by going to <a href="http://radio.rumblesan.com/">http://radio.rumblesan.com/</a></p>

<p>The website is bare, but you can listen to it from there, or turn your stream player of choice to <a href="http://radio.rumblesan.com:8000/radio.ogg">http://radio.rumblesan.com:8000/radio.ogg</a></p>

<p>The system is all run by a python script that starts up an instance of PureData and then dynamically loads generative music patches, letting each play for about ten minutes before fading over to the next. Currently there are only five patches I’ve built and there’s still plenty of stuff I want to do with them, let alone all the other patches that will need to be made.</p>

<p>And this is why I’m going to be recruiting! All the patches currently on there are available on GitHub and I’m going to be using that as a central repository to hold everything. Tomorrow I’m going to write up a spec for how the audio patches interact with the master patch and how everything works (it’s really pretty simple)  and then I’m going to start recruiting properly. I’ll also be going back to doing regular patches, with the idea being that they will just get added to the main patch folder and help everything grow.</p>

<p>So, <a href="https://github.com/rumblesan/PatchWerk-Radio">PatchWerk-Radio</a> is where you can get the code to run the server and <a href="https://github.com/rumblesan/Radio-Patches">PatchWork-Patches</a>. Tomorrow I’ll explain the workings of it and then there’s no excuse.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Radio Drone taking shape]]></title>
    <link href="http://rumblesan.com/blog/2011/01/10/radio-drone-taking-shape/"/>
    <updated>2011-01-10T17:32:44+00:00</updated>
    <id>http://rumblesan.com/blog/2011/01/10/radio-drone-taking-shape</id>
    <content type="html"><![CDATA[<p>I’m definitely going to have to come up with a better name than “Radio Drone”. It sells the whole thing a bit short I think. I’ll carry on using it as the working name for this project until it’s actually ready to publicly unveil but a re-branding is needed.</p>

<p>Anyway, my weekend was taken up with plenty of programming and there is some amount of structure appearing from out of the murk. I have a new <a href="https://github.com/rumblesan/Radio-PD">repository up on GitHub</a> that holds the code and I’m managing to get back into Python despite the rust that develops in the six month breaks I seem to have between using it.</p>

<p>So far I’ve modified the PyPD library so that all communication happens over one port that can be set when Pure Data starts up. Previously the use of the netreceive object meant that the communication port had to be fixed, which was a bit of a speed bump. Modifying the interface abstraction to use the netclient object from the pd-extended MaxLib and a bit of a change to the Python has fixed this.</p>

<p>For the foreseeable I’m also going to be sticking with my plan to have a master patch that does all the cross fading and streaming. Unless testing shows that this is problematic, which I don’t expect but that’s why I’ll be testing.</p>

<p>Lastly, everything will be connected using Jack. It’s solid, easy to use and means that the individual patches don’t have to have any extra stuff other than the python interface abstraction. I’ve written a python class that can start the jack daemon and wraps the command line binaries so that Python can more easily connect and organise programs. The PyJack library seemed a little overkill for what I wanted but may well still be used eventually but for the moment I’m trying to keep things simple.</p>

<p>There’s still plenty to implement and I need to do lots of testing to make sure it’s solid but it’s out in the open now and being worked on. I suppose that I’m going to have to start looking into the server side of it soon and see if I can comfortable get this thing running on a Virtual Server. If push comes to shove I suppose I can just rent a proper dedicated box but I’d like to keep costs down for the moment.</p>

<p>In other news, I realise that I didn’t get a patch made for Friday like I said I would. I feel that this is kind of offsetting that but at the same time I feel a bit bad. I’ll try to get something out in the next couple of days to make up for it. I actually received a copy of <a href="http://www.amazon.co.uk/gp/product/0199298939/ref=oss_product">this book on Music and Mathematics</a> today so I’ll have a look through it later and might try and pull something from it to use.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drones, Python, JACK and Windfarms]]></title>
    <link href="http://rumblesan.com/blog/2011/01/03/drones-python-jack-and-windfarms/"/>
    <updated>2011-01-03T21:03:02+00:00</updated>
    <id>http://rumblesan.com/blog/2011/01/03/drones-python-jack-and-windfarms</id>
    <content type="html"><![CDATA[<p>Thanks to a bank holiday today, I was able to swap going to work for other, more productive activities. As well as playing Super Meat Boy and improving my speed runs in Mirror’s Edge, I actually sat down to start working out how I can get Radio Drone working. The downside of this was that the only Linux machines I have are my rack mount servers which, while very capable, sound like vacuum cleaners. Thankfully I only needed one of them on but it started grating after an hour or two.</p>

<p>I do have a plan now though.</p>

<p>Thanks to the <a href="http://mccormick.cx/projects/PyPd/">PyPD package</a> made by Chris McCormick, It’s possible to have python start up and control an instance of Pure Data. Combining this with the Python JACK package should mean that I can have a python daemon that will start up separate instances of PD with a chosen patch, dynamically connect these to a streaming system and happily mix between them.</p>

<p>That’s the theory at least, in practise I spent much of my time wrangling with installing the correct packages on my Linux box. I think it might be necessary to have a third instance of PureData that does the streaming and mixing but I need to do some more investigation. In any case, it’s nice to be off to some sort of start.</p>

<p>I’m also glad that I’ll be able to reuse some of the code from my Python Render Farm scripts to make the daemon. really it’s just a case of sitting down and designing the infrastructure now…….</p>

<p>In other news, the rhythmic noise EP is taking shape so should be out the door sooner rather than later. I’m also hoping to have a new patch up this week which will be the first of many I hope. I figure that sticking to a weekly patch cycle is enough to keep me thinking but without the slight mental overload that I had in November.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github project links]]></title>
    <link href="http://rumblesan.com/blog/2010/09/08/github-project-links/"/>
    <updated>2010-09-08T11:18:54+01:00</updated>
    <id>http://rumblesan.com/blog/2010/09/08/github-project-links</id>
    <content type="html"><![CDATA[<p>So if you look in the sidebar on the right, you should now see a nice set of links to my Github repositories. Most of it now is now NDS related code but there’s a reasonable amount of python in there.</p>

<p>Eventually there will be some SuperCollider projects to be found but I still have plenty of learning to do before its anything other than the code examples from the site so far.</p>

<p>Feel free to have a browse.</p>
]]></content>
  </entry>
  
</feed>
