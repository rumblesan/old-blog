<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SuperCollider | RumbleSan Heavy Noise Industries]]></title>
  <link href="http://rumblesan.com/blog/categories/supercollider/atom.xml" rel="self"/>
  <link href="http://rumblesan.com/"/>
  <updated>2012-12-16T21:40:44+00:00</updated>
  <id>http://rumblesan.com/</id>
  <author>
    <name><![CDATA[guy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Drum Sounds in SuperCollider (part 2)]]></title>
    <link href="http://rumblesan.com/blog/2010/10/15/drum-sounds-in-supercollider-part-2/"/>
    <updated>2010-10-15T17:54:06+01:00</updated>
    <id>http://rumblesan.com/blog/2010/10/15/drum-sounds-in-supercollider-part-2</id>
    <content type="html"><![CDATA[<p>So Part two of the Drum Sounds in SuperCollider series, and we’re going to be making a snare and a clap. Not necessarily a realistic snare or clap, but reasonable enough to go with the rest of our kit. It will be mostly the same combinations of simple oscillators, noise sources, filters and envelopes as previously but joining them in slightly different ways. Again, the S<a href="http://www.soundonsound.com/sos/allsynthsecrets.htm">ynth Secrets articles</a> are  great to read for some in depth info and good ideas on this sort of stuff, so I’ll link them again.</p>

<p>The snare circuit for the 808 actually functions in a similar way to our full kick drum. There are the same two parts, one a resonant filter based drum sound and the other an enveloped noise source. Obviously the drums are tuned to a higher frequency and the noise is differently filtered to give a better snare effect, but otherwise we could take our full kick, change some of the frequencies we chose and we’d be in the right area.</p>

<p>But reusing the same concepts would be a little boring so I’ve decided on another route. When a real drum is hit, the actual sound of it is a spectrum of different frequencies, some of which die out very quickly and others that sound for longer. In many ways it could be thought of as a bell, the difference being that with a drum the higher frequencies die out almost straight away and its the much lower register tones that carry on longer. That burst of higher frequencies at the beginning are what’s responsible for the attack of the drum sound, which is why our full kick has the brief noise burst.</p>

<p>So what we really want in a drum sound is a brief hit of higher frequencies with the lower frequencies taking longer to decay. And to do it, we’re going to use a simple envelope to modify the frequency cutoff of a filter. We need a sound source with a wide frequency content and whilst we could use a noise source for this, choosing a square wave will give us more options for tuning and shaping the sound later. Low Pass Filter sweeping down with a Pulse UGen as the source is the plan.</p>

<p>Again, a Line UGen will work fine as our envelope but this time we need it to control a frequency with a large range, not the volume with a 1 to 0 range. SuperCollider makes everything pretty easy for us in this respect because we can just plug UGens in where we want and use them like we would other variables. Our Low Pass filter wants to know what it’s filtering and at what frequency, we want the sweep to start around 1 KHz and decrease to something just above 0 Hz. We just plug our Line UGen in where the LPF frequency argument is, multiply it by 1000 and add 30 to the result. We’ll put a volume envelope around this as well which will have a longer decay so that the lower frequencies can carry on a bit. That will also have a doneAction so that the synth frees up after it’s played and then we’re basically finished. The code for the complete drum sound looks like this.</p>

<pre><code>(
SynthDef('snaredrum', {

var drumosc, filterenv, drumoutput, volenv;

filterenv = {Line.ar(1, 0, 0.2, doneAction: 0)};
volenv = {Line.ar(1, 0, 0.6, doneAction: 2)};

drumosc = {Pulse.ar(100)};
drumoutput = {LPF.ar(drumosc,(filterenv *1000) + 30)};

Out.ar(0,
Pan2.ar(drumoutput * volenv, 0)
)

}).send(s);
)

t = Synth('snaredrum');
</code></pre>

<p>Reasonable enough sounding I think for what we need, I’ve picked the values by ear but change them if you want.</p>

<p>The snare part of the sound is again going to be similar to the high hat, but I’m filtering the noise with a bandpass filter to get the right range for a snare and a low pass filter to differentiate it from the hats a bit more. A relatively simple volume envelope used and then mixing that with the drum sound gives us our finished snare.</p>

<pre><code>(
SynthDef('snaredrum', {

var drumosc, filterenv, volenv, drumoutput, snaposc, snapenv, fulloutput;

drumosc = {Pulse.ar(100)};
filterenv = {Line.ar(1, 0, 0.2, doneAction: 0)};
volenv = {Line.ar(1, 0, 0.6, doneAction: 2)};
drumoutput = {LPF.ar(drumosc,(filterenv *1000) + 30)};

snaposc = {BPF.ar(HPF.ar(WhiteNoise.ar(1),500),1500)};
snapenv = {Line.ar(1, 0, 0.2, doneAction: 0)};

fulloutput = (drumoutput * volenv) + (snaposc * snapenv);
//fulloutput = (drumoutput * volenv);

Out.ar(0,
Pan2.ar(fulloutput, 0)
)

}).send(s);
)

t = Synth('snaredrum');
</code></pre>

<p>Finally, it’s on to the clap. I’m not so pleased with how this one has turned out, but it shows off what I wanted so I feel that I’ll finish this article and then improve it later. A clap sound is much like the snare sound we had earlier but a single clap on it’s own can sound a bit drab. When recording claps, it’s much better if they can be layered, and better still if there is a slight timing difference between all the claps to help it sound fuller. Roland tackled the problem by having a volume envelope that had multiple peaks in quick succession and then modulated a noise source with this but I couldn’t get that to sound quite right. Instead I’m using the Fill functionality of the Mix UGen with an EnvGen to effectively mix multiple single clap sounds with different start offsets.</p>

<p>The EnvGen takes an array of envelope values and another array that has the times required to move between them. If we have the first two values set to zero then we can use a variable for the change time and control the time it takes for the clap to sound. We can create some quite complex envelopes using this but here we will just use it to have an offset before a simple line envelope.</p>

<p>When using the Mix UGens Fill functionality, we give it a number and then a function. It will fill an array of however many elements we specify with the results of the function and then mix that array down into one channel. If we specify an argument within this function, then the Mix will automatically increment it by one every time it goes to fill a new array element. What this means is that we can have the first time value in the EnvGen be multiplied by this arg, and each array element will have a slightly longer start offset than the last. In this way we can mix multiple single clap sounds and give them a degree of time separation. I think they’re should be a neater way to do the code but I’ve not quite gotten to grips with all the syntax. Another thing to learn and update in future i guess.</p>

<pre><code>(
SynthDef('clap', {

var claposc, clapenv, clapnoise, clapoutput;

clapnoise = {BPF.ar(LPF.ar(WhiteNoise.ar(1),7500),1500)};
clapenv = {Line.ar(1, 0, 0.6, doneAction: 2)};

clapoutput = {Mix.arFill(7,
{arg i;
EnvGen.ar(
Env.new(
[0,0,1,0],
[0.01 * i,0,0.04]
)
) * clapnoise * 0.5
}
)};

Out.ar(0,
Pan2.ar(clapoutput * clapenv, 0)
)

}).send(s);
)

t = Synth('clap');
</code></pre>

<p>I’ve chosen different frequencies for filtering the noise source again to make it sound different from the other noise used in the rest of the kit. I still think the clap sound needs to most work but it gave me a chance to show how the Mix Fill and EnvGen can be used together so it’s OK for now.</p>

<p>So that finishes our basic set of drum sounds for the moment. The next step is going to be integrating Pure Data and SuperCollider over OSC so that we can have one control the other and actually make some music. I’ll need to do a bit of investigation on the best way to make that happen</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drum Sounds in SuperCollider (Part 1)]]></title>
    <link href="http://rumblesan.com/blog/2010/10/12/drum-sounds-in-supercollider-part-1/"/>
    <updated>2010-10-12T16:03:53+01:00</updated>
    <id>http://rumblesan.com/blog/2010/10/12/drum-sounds-in-supercollider-part-1</id>
    <content type="html"><![CDATA[<p>I feel it’s about time I tried to build something useful in SuperCollider since up until now I’ve mostly just been making examples. Synthesising drum sounds seems like a good place to start and it will also give me something to use when showing how to get Pure Data and SuperCollider interacting over OSC. The focus will be on making the sounds and not so much on how to control them so it will just be single synth instances that make a noise when they’re created and then free themselves. This is going to be a two part post again with the Kick and Hat sounds covered here as a starter, and the Clap and Snare sounds covered in a later post since they were marginally more complex and it wouldn’t hurt to have a few basics first.</p>

<p>I’ll be sticking to the basic and obvious electronic drum sounds for the most part. It isn’t pushing any boundaries for new and innovative methods but I’m more interested in learning the necessary skills to get SuperCollider to do what I want. I plan to create these now and then revise them gradually later down the line so with that in mind, I’ll be creating 808 and 909 style sounds where the main focus will be on a kick, a snare, open and closed hi hats and a clap, probably with a couple of other bits thrown in for good measure. These won’t be accurate reproductions of Roland’s drum sounds, just taking some basic techniques for analogue synthesis and applying them to SuperCollider. Some of the info here has come from the Sound on Sound synth secrets articles which are a really amazing source of knowledge and deserve a good read.</p>

<p>So, first up we have the kick, which has two parts to it that are both very similar. The obvious bass section of the sound as well as the percussive click at the beginning. We will generate the drum sound and the initial click separately using a sine oscillator and a noise source respectively which are each modified by separate envelope generators. This is a fairly simplistic way of synthesising drum sounds but this serves well enough to be useful.
The bass portion of the sound will be handled by a SinOsc tuned to 60 Hertz. Obviously we need to shape this so that it dies out relatively quickly and a Line UGen will serve as a volume envelope. The Line has a doneAction so that once the envelope has finished the synth will free itself and we can trigger it again if needed. The below code shows how all of this fits together. It’s quite verbose but should be easily understandable, Oscillator multiplied by Volume envelope.</p>

<p>```
(
SynthDef(‘kickdrum’, {</p>

<pre><code>var osc, env, output;

osc = {SinOsc.ar(60)};
env = {Line.ar(1, 0, 1, doneAction: 2)};

output = osc * env;

Out.ar(0,
    Pan2.ar(output, 0)
)
</code></pre>

<p>}).send(s);
)</p>

<p>t = Synth(‘kickdrum’);
```</p>

<p>Adding the click at the beginning involves basically the same process but with a noise source. We’ll put a Noise UGen through a Low Pass Filter UGen to make it sound more like a thump and then use a second Line UGen with a much quicker decay. It’s important to note that there isn’t a doneAction here, we don’t want the synth to free itself up before the bass envelope has finished otherwise the sound will be clipped off. If in future we have variable length envelopes involved here then we’re going to need to change how this works but it will do for the moment.
We combine both of these and the end result is a reasonable bass drum sound that while not great, works well and can easily be improved later.</p>

<p>```
    (
        SynthDef(‘fullkickdrum’, {</p>

<pre><code>    var subosc, subenv, suboutput, clickosc, clickenv, clickoutput;

    subosc = {SinOsc.ar(60)};
    subenv = {Line.ar(1, 0, 1, doneAction: 2)};

    clickosc = {LPF.ar(WhiteNoise.ar(1),1500)};
    clickenv = {Line.ar(1, 0, 0.02)};

    suboutput = (subosc * subenv);
    clickoutput = (clickosc * clickenv);

    Out.ar(0,
        Pan2.ar(suboutput + clickoutput, 0)
    )

}).send(s);
)

t = Synth('fullkickdrum'); ```
</code></pre>

<p>With that done it’s on to the Hi Hats. This works much the same as the click sound from the bass drum but we have a slightly different volume envelope decays and different filtering on the noise. The difference between an open and a closed hat here will just be the length of the decay, everything else remains the same for each. Again the Noise UGen is low pass filtered but this time we let more of the higher frequencies through. We also filter it through a High Pass Filter UGen after that so that we get less thump and more of a mid range emphasis. I’ve chosen some values that I feel are fine here but there’s plenty of scope for tuning. We could probably just use a single Band Pass Filter but I feel this gives a degree more control over the sound. The volume envelope is again created using a Line UGen, with the open hat having a longer decay than the closed hat. I’ve created the two as separate synths here but they could easily be combined into a single one with controls.</p>

<p>```
(
SynthDef(‘openhat’, {</p>

<pre><code>var hatosc, hatenv, hatnoise, hatoutput;

hatnoise = {LPF.ar(WhiteNoise.ar(1),6000)};

hatosc = {HPF.ar(hatnoise,2000)};
hatenv = {Line.ar(1, 0, 0.3)};

hatoutput = (hatosc * hatenv);

Out.ar(0,
Pan2.ar(hatoutput, 0)
)
</code></pre>

<p>}).send(s);</p>

<p>SynthDef(‘closedhat’, {</p>

<pre><code>var hatosc, hatenv, hatnoise, hatoutput;

hatnoise = {LPF.ar(WhiteNoise.ar(1),6000)};

hatosc = {HPF.ar(hatnoise,2000)};
hatenv = {Line.ar(1, 0, 0.1)};

hatoutput = (hatosc * hatenv);

Out.ar(0,
Pan2.ar(hatoutput, 0)
)
</code></pre>

<p>}).send(s);
)</p>

<p>o = Synth(‘openhat’);
c = Synth(‘closedhat’);
```</p>

<p>So that’s it for this part like I said, the next part will be the Clap and the Snare sounds at which point we’ll have most of the stuff we need for a basic drum kit. This will be an ongoing thing, gradually having more sounds added and existing ones improved so it should become a genuinely useful piece of code. Part 2 coming soon</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodes, Graphs, Groups and Positioning (part 2)]]></title>
    <link href="http://rumblesan.com/blog/2010/09/29/nodes-graphs-groups-and-positioning-part-2/"/>
    <updated>2010-09-29T10:58:02+01:00</updated>
    <id>http://rumblesan.com/blog/2010/09/29/nodes-graphs-groups-and-positioning-part-2</id>
    <content type="html"><![CDATA[<p>So here is part two of the series on Nodes, Graphs, Groups and Positioning which will have a bit more code than the last one but shouldn’t be much trickier to follow. I’ll specifically be dealing with Positioning here, and how some Nodes need to come after other Nodes to get the results you want.</p>

<p>We’ll start off with the Simple-FM synth that I’ve used previously, it’s very uninteresting but will be good for explaining what we’re doing.</p>

<pre><code>(
SynthDef('basic-FM',{

arg freq1 = 440, amp1 = 30,
freq2 = 150, amp2 = 0.5;

var osc1, osc2;

osc1 = {SinOsc.ar(freq1) * amp1};
osc2 = {SinOsc.ar(freq2 + osc1)};

Out.ar(0,
Pan2.ar(osc2, 0)
)

}).send(s)

t = Synth('basic-FM',['freq2', 200, 'amp1', 100]);

)
</code></pre>

<p>It’s fairly dissonant because we’re going to be putting this through a Low Pass filter and I want it to be obvious when the sound is changing.</p>

<p>Our Low Pass filter code looks like this:-</p>

<pre><code>(

SynthDef('LPFilter',{

arg freq = 1000, inBus, outBus = 0;
var filter;

filter = {LPF.ar(In.ar(inBus), freq)};

Out.ar(outBus,
Pan2.ar(filter, 0)
)
})

)
</code></pre>

<p>There isn’t really much to it, we have a Low Pass filter UGen around an In UGen so it will filter whatever comes in through the audio bus with the cutoff frequency set by the freq variable. Lets put it all together to start things working. We need to modify the FM synth to send its output to an audio bus so we can pipe it into the filter but otherwise not much changes.</p>

<pre><code>(
SynthDef('basic-FM',{

arg freq1 = 440, amp1 = 30,
freq2 = 150, amp2 = 0.5,
outBus = 0;

var osc1, osc2;

osc1 = {SinOsc.ar(freq1) * amp1};
osc2 = {SinOsc.ar(freq2 + osc1)};

Out.ar(outBus,
Pan2.ar(osc2, 0)
)

}).send(s)

SynthDef('LPFilter',{

arg freq = 1000, inBus, outBus = 0;
var filter;

filter = {LPF.ar(In.ar(inBus), freq)};

Out.ar(outBus,
Pan2.ar(filter, 0)
)
}).send(s)

)

d = Bus.audio(s, 1);
t = Synth('basic-FM',['freq2', 200, 'amp1', 100, 'outBus' d]);
f = Synth('LPFilter',['freq', 1000, 'inBus', d]);

f.set('freq', 300);
</code></pre>

<p>…….. if you run and you don’t hear anything, don’t worry, you shouldn’t be.  Let’s go through what’s happening here. We have two Nodes, the basic-FM synth and the LPFilter, and the references to these Nodes are stored in the <strong>t</strong> and <strong>f</strong> variables. Both of these Nodes are in the Global Group because we haven’t told the server to put them anywhere else. We would probably expect that, as we create the filter node after the synth node, everything would be peachy but clearly it’s not quite that simple.</p>

<p>When we create a new synth, there are a few arguments that we miss out, so they take their default values. One of these is called the <em>addAction</em> and we can use it to specify the position in the group that new Nodes take in relation to other Nodes. The default for this is <em>addToHead</em>, so despite us creating the nodes in the order we want, because the Filter Node is created after the synth Node, it will be added to the head of the group it’s in.</p>

<p>There are a couple of ways we can fix this. Obviously we can change the addAction and I’ll get to this in a moment.</p>

<p>A simple solution would be to reverse the order that the nodes are created in, and if you try it out you’ll hear that it works. Have a play with changing the frequency of the filter as well once its working.</p>

<p>We can also manually change the ordering of the nodes. After running the above code with the synth first, use</p>

<pre><code>t.moveBefore(f);
</code></pre>

<p>or</p>

<pre><code>f.moveAfter(t);
</code></pre>

<p>to reorder the nodes. There are a number of messages for node reordering. Have a scour through the docs for more on this.</p>

<p>In the long run, the addActions seem to be the best way to create and keep the order of nodes once we start getting complex. The syntax doesn’t really add much into what we have and it means that we can easily set the order of lots of Nodes with relation to each other. The full list of arguments for the Synth.new method are:-</p>

<p><strong>Synth.new(defName, args, target, addAction)</strong></p>

<p>Where target is a synth or server and add action specifies what we want to do. In this case, we can update the section of code where we create our synths and the audio bus and enclose the whole lot in brackets so we can create it in one go and have the addAction correctly specify the ordering.</p>

<pre><code>(
d = Bus.audio(s, 1);
t = Synth('basic-FM',['freq2', 200, 'amp1', 100, 'outBus', d]);
f = Synth('LPFilter',['freq', 10000, 'inBus', d], t, 'addAfter');
)
</code></pre>

<p>The addAction for the filter synth tells it to position it after node t which means our signal chain is in the correct order and we get sound.</p>

<p>For more info on this, the place to check out is the documentation on <a href="http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/Order-of-execution.html">Order of Execution</a>. It gives more examples and expands on the add actions and some of the other things I’ve shown. The next and possibly final instalment of this series of posts will be about direct Node messaging where we do away with the niceties that the SuperCollider language functions give us and just send direct OSC to Nodes.</p>

<p>Keep playing</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithmic Experiments]]></title>
    <link href="http://rumblesan.com/blog/2010/09/16/algorithmic-experiments/"/>
    <updated>2010-09-16T10:53:19+01:00</updated>
    <id>http://rumblesan.com/blog/2010/09/16/algorithmic-experiments</id>
    <content type="html"><![CDATA[<p>One of the things I’ve always been interested in is the idea of algorithmic, generative music. I think it’s stemmed from a love of complex, glitchy music but wanting to be able to create it live instead of just replaying loops or sections and this is still something I struggle with now.</p>

<p>I think I’m going to start expanding this blog somewhat based on this. Initially I was just going to be using it as a place to post SuperCollider stuff as I learnt more about the program, but that itself just seems to be a small part of the whole.</p>

<p>So, here is my plan. Each week I will come up with an idea, build an example of it, learn about it, try and explain my thoughts about it and post up the code for anybody to use. Sometimes I might be expanding on a previous idea, sometimes I will try and come up with something new, sometimes I might just wholesale take someone else’s idea and try to modify it in my own way or maybe just learn about it. I am also going to try and have a weekly post on a SuperCollider, PureData or Max/MSP lesson. Looking back at the previous SuperCollider stuff I’m already seeing mistakes so these might only be of use to me but so be it.</p>

<p>As a heads up, I can say that the first example is going to be based on Markov Chains, since I’ve already spent some time playing about with them and I want to investigate them more.</p>

<p>Hopefully I’ll be able to get hat and an SC lesson done by the end of the weekend.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodes, Graphs, Groups and Positioning (part 1)]]></title>
    <link href="http://rumblesan.com/blog/2010/09/08/nodes-graphs-groups-and-positioning-part-1/"/>
    <updated>2010-09-08T12:03:49+01:00</updated>
    <id>http://rumblesan.com/blog/2010/09/08/nodes-graphs-groups-and-positioning-part-1</id>
    <content type="html"><![CDATA[<p>So I’ve been reading up more on this, as I feel it’s one of the last major things to get my head around before fully understanding SuperCollider.  The premise is pretty simple but I found there’s an awful lot of depth to it if you start diving in. For this reason there will be a couple of parts to this, I’m guessing two or three.</p>

<p>The basics is where we’ll start and, thankfully, they aren’t to taxing. There won’t be much code in this post but there should be a fair few diagrams to help visualise everything.</p>

<p>To begin with, I’ll introduce the four big words I used in the title.</p>

<p><strong>Nodes, Graphs, Groups and Positioning.</strong></p>

<p>The three of these are all quite strongly tied together but have slightly differing meanings depending on whether you’re looking at the maths, or at SuperCollider itself. In the mathematical sense, a Graph (not in an x-y diagram sense) is essentially a number of vertices joined by edges. This creates a network that can be used to do various things, the <a href="http://en.wikipedia.org/wiki/Graph_%28mathematics%29">wikipedia article</a> is very good at explaining some of this and infact I’ll lift a picture from it here quickly.</p>

<p><img src="http://en.wikipedia.org/wiki/Graph_%28mathematics%29" alt="Mathematical Graph" /></p>

<p>SuperCollider uses graphs internally when dealing with Synths that it is running to calculate in what order the functionality of the UGens should be happening. It is doubtful the user will have to deal with this themselves.</p>

<p>Nodes and Groups are something that you will deal with often if you use SuperCollider. A Node can be a single Synth or a Group on the server. A Group can be a collection of Synth Nodes and/or more Group Nodes.</p>

<p><code>
t = Synth('basic-FM',['freq2', 200, 'amp1', 300]);
</code></p>

<p>The above code for example is us creating a Synth and storing a reference to it in the variable t. The reference we are actually storing is the ID of the Node on the Server so when we run commands that refer to a synth, we’re actually just sending messages to that Node.</p>

<p>To make it easier to control and manage multiple Nodes, they can be collected into a single Group which makes life much easier when having to think about Positioning.</p>

<p>Positioning isn’t really that difficult to get your head around. If we have a synth, and the audio from that goes through an effect, then the sound out of the effect is dependant upon the sound out of that synth. We need to make sure that SuperCollider calculates the synth’s audio so that the effect can modify it. If we were to create the synth first and then the effect then the effect node would come after the synth node by default but it’s not always such a good idea to rely on this, especially not if things get complicated. I’ll be covering how you can tell SuperCollider what order things should be in in a later post, I’m just trying to get through the idea that this is important to think about but not too complex. A picture from the documentation on <a href="http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/Order-of-execution.html">Order of Execution</a> might make things a little clearer.</p>

<p><img src="http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/Order-of-execution.html" alt="Order of execution diagram" /></p>

<p>It is also worth mentioning here that ordering works much the same for Groups as it does for Nodes. We can have a group of nodes that all represent synths and this group is positioned before an effect node so that the output from the synths is calculated and mixed together, before going to the effect.</p>

<p>So, to round everything up, a quick overview in bullet point format.</p>

<ul>
  <li>
    <p>The SuperCollider server keeps track of Synths and Groups as Nodes</p>
  </li>
  <li>
    <p>A Group is a collection of Nodes itself</p>
  </li>
  <li>
    <p>The internals of a Synth Node will be a Graph of UGens created from the SynthDef</p>
  </li>
  <li>
    <p>The Nodes will have an order and this can be set and changed</p>
  </li>
  <li>
    <p>A Node that is dependant upon the audio from another Node must be placed after it</p>
  </li>
</ul>

<p>Part two should have some more code examples, probably something simple involving a synth and an effect and I’ll aim to start getting the code examples up on Github.</p>

]]></content>
  </entry>
  
</feed>
